From: http://stackoverflow.com/questions/9478168/tsl-ssl-configuration-of-spring-http-invoker
    Problem already solved! I kind of mixed up keystore with truststore. So if
    you found this question and look for an answer, take a look at: Trust Store
    vs Key Store - creating with keytool. In short: you have to create a
    certificate which you put in a keystore for the server and in a truststore
    for the client. Well, essentially there is no real different between
    keystore and truststore, the only difference is that you use different
    System-properties to define them in your program. (e.g.
    javax.net.ssl.trustStore for the truststore). Thats where i messed up!

    I am still interested in reasons on whether or not to use Spring HTTP
    Invoker though.

From: http://stackoverflow.com/questions/6340918/trust-store-vs-key-store-creating-with-keytool
    The terminology is a bit confusing indeed, but both javax.net.ssl.keyStore
    and javax.net.ssl.trustStore are used to specify which keystores to use,
    for two different purposes. Keystores come in various formats and are not
    even necessarily files (see this question), and keytool is just a tool to
    perform various operations on them (import/export/list/...).

    The javax.net.ssl.keyStore and javax.net.ssl.trustStore parameters are the
    default parameters used to build KeyManagers and TrustManagers
    (respectively), then used to build an SSLContext which essentially contains
    the SSL/TLS settings to use when making an SSL/TLS connection via an
    SSLSocketFactory or an SSLEngine. These system properties are just where
    the default values come from, which is then used by
    SSLContext.getDefault(), itself used by SSLSocketFactory.getDefault() for
    example. (All of this can be customized via the API in a number of places,
    if you don't want to use the default values and that specific SSLContexts
    for a given purpose.)

    The difference between the KeyManager and TrustManager (and thus between
    javax.net.ssl.keyStore and javax.net.ssl.trustStore) is as follows (quoted
    from the JSSE ref guide):

    TrustManager: Determines whether the remote authentication credentials (and
    thus the connection) should be trusted.

    KeyManager: Determines which authentication credentials to send to the
    remote host.  (Other parameters are available and their default values are
    described in the JSSE ref guide. Note that while there is a default value
    for the trust store, there isn't one for the key store.)

    Essentially, the keystore in javax.net.ssl.keyStore is meant to contain
    your private keys and certificates, whereas the javax.net.ssl.trustStore is
    meant to contain the CA certificates you're willing to trust when a remote
    party presents its certificate. In some cases, they can be one and the same
    store, although it's often better practice to use distinct stores
    (especially when they're file-based).

From: http://www.webfarmr.eu/2010/04/import-pkcs12-private-keys-into-jks-keystores-using-java-keytool/
    Import PKCS12 private keys into JKS keystores using Java Keytool

# Adding parameters to spring-boot:run works:
mvn clean spring-boot:run -Djavax.net.debug=ssl -Djavax.net.ssl.trustStore=/tmp/keystore.p12 -Djavax.net.ssl.trustStorePassword=mypassword

# Generate the key.
keytool -genkey \
    -alias tomcat \
    -storetype PKCS12 \
    -keyalg RSA \
    -keysize 2048 \
    -keystore keystore.p12 \
    -dname "CN=Dan Barrese, OU=Unknown, O=Active Bean Coders, L=Denver, ST=CO, C=US" \
    -keypass mypassword \
    -storepass mypassword \
    -ext SAN=DNS:localhost,IP:127.0.0.1 \
    -validity 3650

# Import it into the JRE.
keytool -v -importkeystore -srckeystore keystore.p12 -srcstoretype PKCS12 -destkeystore truststore.jks -deststoretype JKS

